#!/bin/sh
# run-dynamic-user: wrapper to launch a runit service with a secure, unprivileged dynamic user
# Usage (in service run script): /path/to/run-dynamic-user --service NAME [--create-home] -- <command> [args...]
# Example runit run script:
#   #!/bin/sh
#   exec /path/to/run-dynamic-user --service myservice --create-home -- your-daemon --flags

set -eu
umask 077

if [ "$(id -u)" -ne 0 ]; then
    echo "Error: This script must be run as root." >&2
    exit 1
fi

usage() {
    echo "Usage: $0 --service NAME [--create-home] -- <command> [args...]" >&2
    exit 1
}

enable_home=false
SERVICE=""
while [ "$#" -gt 0 ]; do
    case "$1" in
    --service)
        SERVICE="${2-}"
        case "$SERVICE" in
        [A-Za-z0-9_-]*) ;;
        *) usage ;;
        esac
        shift 2
        ;;
    --create-home)
        enable_home=true
        shift
        ;;
    --)
        shift
        break
        ;;
    *)
        usage
        ;;
    esac
done

[ "$#" -ge 1 ] || usage

if [ -z "$SERVICE" ]; then
    echo "Service name is required (use --service)." >&2
    usage
fi

OS="$(uname -s)"
case "$OS" in
Linux) RUNTIME_BASE="/run" ;;
FreeBSD) RUNTIME_BASE="/var/run" ;;
*)
    echo "Unsupported OS: $OS" >&2
    exit 1
    ;;
esac
[ -d "$RUNTIME_BASE" ] || RUNTIME_BASE="/run"

if [ -d "/var/lib" ]; then
    PERSIST_BASE="/var/lib/runit-dynuser"
else
    PERSIST_BASE="/var/db/runit-dynuser"
fi

add_group() {
    name="$1"
    gid="$2"
    case "$OS" in
    Linux) groupadd -g "$gid" "$name" ;;
    FreeBSD) pw groupadd -n "$name" -g "$gid" ;;
    esac
}

add_user() {
    name="$1"
    uid="$2"
    gid="$3"
    home="$4"
    case "$OS" in
    Linux)
        useradd -u "$uid" -g "$gid" -d "$home" -M -N -r -s /usr/sbin/nologin "$name"
        ;;
    FreeBSD)
        pw useradd -n "$name" -u "$uid" -g "$gid" -d "$home" -w no -s /usr/sbin/nologin
        ;;
    esac
}

del_user() {
    name="$1"
    case "$OS" in
    Linux) userdel -f "$name" ;;
    FreeBSD) pw userdel -n "$name" -r ;;
    esac
}

del_group() {
    name="$1"
    case "$OS" in
    Linux) groupdel "$name" ;;
    FreeBSD) pw groupdel -n "$name" ;;
    esac
}

SCRIPT_DIR=$(cd -- "$(dirname -- "$0")" && pwd -P)
FINISH_HELPER="$SCRIPT_DIR/finish-dynamic-user"

ROOT_GROUP="$(id -gn 0)"

SRV_RUN="${RUNTIME_BASE}/${SERVICE}"
PERSIST_DIR="${PERSIST_BASE}/${SERVICE}"
PERSIST_ID="${PERSIST_DIR}/identity"

if [ -L "$SRV_RUN" ]; then
    echo "Refusing to use symlinked runtime directory $SRV_RUN" >&2
    exit 1
fi

if [ -e "$SRV_RUN" ]; then
    STALE="true"
fi

if [ -L "$PERSIST_DIR" ]; then
    echo "Refusing to use symlinked persistent directory $PERSIST_DIR" >&2
    exit 1
fi

if [ -e "$PERSIST_ID" ]; then
    STALE="true"
fi

if [ "${STALE-}" = "true" ]; then
    if [ ! -x "$FINISH_HELPER" ]; then
        echo "Stale dynamic user state detected but $FINISH_HELPER is not executable." >&2
        exit 1
    fi
    echo "Stale dynamic user state detected; invoking finish-dynamic-user for $SERVICE" >&2
    if ! "$FINISH_HELPER" --service "$SERVICE"; then
        echo "Failed to clean previous dynamic user state for $SERVICE." >&2
        exit 1
    fi
fi

if [ -e "$SRV_RUN" ] || [ -e "$PERSIST_ID" ]; then
    echo "Refusing to start: dynamic user state still present for $SERVICE." >&2
    exit 1
fi

UID=""
GID=""
CLEAN_USER=""
CLEAN_GROUP=""
CLEAN_PERSIST=false
cleanup() {
    # Cleanup only runs if setup fails before exec
    if [ -n "$CLEAN_USER" ] && [ -n "$UID" ]; then
        pkill -u "$UID" >/dev/null 2>&1 || true
    fi
    if [ -n "$CLEAN_USER" ]; then
        del_user "$CLEAN_USER" >/dev/null 2>&1 || true
    fi
    if [ -n "$CLEAN_GROUP" ]; then
        del_group "$CLEAN_GROUP" >/dev/null 2>&1 || true
    fi
    if [ -d "$SRV_RUN" ]; then
        rm -rf "$SRV_RUN"
    fi
    if [ "$CLEAN_PERSIST" = true ] && [ -d "$PERSIST_DIR" ]; then
        rm -rf "$PERSIST_DIR"
    fi
}
trap cleanup EXIT INT TERM

install -d -m 700 -o root -g "$ROOT_GROUP" "$SRV_RUN"
install -d -m 700 -o root -g "$ROOT_GROUP" "$PERSIST_DIR"
CLEAN_PERSIST=true

DYN_HOME="/nonexistent"
[ "$enable_home" = true ] && DYN_HOME="$SRV_RUN/home"

# Generate a unique dynamic user/group name
USER=""
GROUP=""
for _ in 1 2 3 4 5; do
    dynrand=$(LC_ALL=C tr -dc 'a-z0-9' </dev/urandom | head -c 10)
    candidate="svc_${SERVICE}_${dynrand}"
    if ! getent passwd "$candidate" >/dev/null 2>&1 && ! getent group "$candidate" >/dev/null 2>&1; then
        USER="$candidate"
        GROUP="$candidate"
        break
    fi
done

if [ -z "$USER" ] || [ -z "$GROUP" ]; then
    echo "Unable to generate unique dynamic user name." >&2
    exit 1
fi

for id in $(seq 60000 64999); do
    if ! getent passwd "$id" >/dev/null 2>&1 && ! getent group "$id" >/dev/null 2>&1; then
        UID="$id"
        GID="$id"
        break
    fi
done

if [ -z "$UID" ] || [ -z "$GID" ]; then
    echo "No free UID/GID available." >&2
    exit 1
fi

add_group "$GROUP" "$GID"
CLEAN_GROUP="$GROUP"
add_user "$USER" "$UID" "$GROUP" "$DYN_HOME"
CLEAN_USER="$USER"

if [ "$enable_home" = true ]; then
    install -d -m 700 -o "$USER" -g "$GROUP" "$DYN_HOME"
fi

printf '%s:%s:%s:%s\n' "$USER" "$UID" "$GROUP" "$GID" >"$PERSIST_ID"
chmod 600 "$PERSIST_ID"

WORKDIR="$SRV_RUN/work"
install -d -m 700 -o "$USER" -g "$GROUP" "$WORKDIR"

# Finally, execute the daemon under the dynamic user
exec chpst -u "$USER:$GROUP" -- "$@"
