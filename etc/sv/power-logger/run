#!/bin/sh
# runit service "power-logger": log power draw to SQL (APC or IPMI)
# Supports SQLite file or PostgreSQL via Unix socket
# -------------------------------------------------------------
# Location: /etc/sv/power-logger/run
# Service account: power-logger
#
# Prerequisites (run once as root):
#   pw groupadd -n power-logger || true
#   pw useradd -n power-logger -g power-logger -c "power logger service" -s /usr/sbin/nologin -d /nonexistent -w no || true
#   install -d -o power-logger -g power-logger /var/db/power-logger
#   install -d -o root -g power-logger -m 755 /etc/sv/power-logger/env
#   cat > /etc/sv/power-logger/env/.env.power-logger <<'EOF'
#   SERVICE_USER=power-logger
#   RING_BUFFER_DAYS=30
#   INTERVAL_SEC=1
#   DB_TYPE=sqlite
#   EOF
#   chmod o= /etc/sv/power-logger/env/.env.power-logger
#   chown -R root:power-logger /etc/sv/power-logger
#
# If using PostgreSQL, also set PGHOST, PGPORT, PGDATABASE, PGUSER in the .env file.
# -------------------------------------------------------------
# Enable service: ln -s /etc/sv/power-logger /var/service/
set -eu

# Load environment
ENV_DIR="$(dirname "$0")/env"
[ -f "$ENV_DIR/.env.power-logger" ] && . "$ENV_DIR/.env.power-logger"

# Defaults
: "${SERVICE_USER:=power-logger}"
: "${RING_BUFFER_DAYS:=30}"
: "${INTERVAL_SEC:=1}"
: "${DB_TYPE:=sqlite}"
: "${DB_FILE:=/var/db/power-logger/power-logger.db}"
: "${PGHOST:=/tmp}"
: "${PGPORT:=5432}"
: "${PGDATABASE:=power_logger_db}"
: "${PGUSER:=power_logger}"
: "${POWER_SOURCE:=apc}"
: "${APCACCESS_BIN:=apcaccess}"
: "${APCACCESS_ARGS:=}"
: "${IPMI_CMD:=ipmitool sdr}"
: "${IPMI_SENSOR:=Power Meter}"

# Drop privileges if needed
if [ "$(id -un)" != "$SERVICE_USER" ]; then
    exec chpst -u "$SERVICE_USER" /bin/sh "$0" "$@"
fi

case "$INTERVAL_SEC" in
'' | *[!0-9]*)
    echo "[power-logger] ERROR: INTERVAL_SEC must be a positive integer." >&2
    exit 1
    ;;
0)
    echo "[power-logger] ERROR: INTERVAL_SEC must be greater than zero." >&2
    exit 1
    ;;
esac

RING_BUFFER_SIZE=$((RING_BUFFER_DAYS * 86400 / INTERVAL_SEC))
[ "$RING_BUFFER_SIZE" -ge 1 ] || RING_BUFFER_SIZE=1

# Common SQL templates
INIT_SCHEMA_SQL=$(
    cat <<'EOS'
-- SQLite or PostgreSQL schema initialization
CREATE TABLE IF NOT EXISTS watts (
    slot      INTEGER PRIMARY KEY,
    ts        %TSTYPE% NOT NULL DEFAULT CURRENT_TIMESTAMP UNIQUE,
    watts     REAL    NOT NULL,
    loadpct   REAL    NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_watts_ts ON watts(ts);
EOS
)

UPSERT_SQL=$(
    cat <<'EOS'
-- SQLite or PostgreSQL upsert
INSERT INTO watts(slot, watts, loadpct) VALUES(
    %SLOT%, %WATTS%, %LOADPCT%
) ON CONFLICT(slot) DO UPDATE SET
    ts       = CURRENT_TIMESTAMP,
    watts    = EXCLUDED.watts,
    loadpct  = EXCLUDED.loadpct;
EOS
)

SELECT_LAST_SLOT="SELECT slot FROM watts ORDER BY ts DESC LIMIT 1;"

# Determine client command and schema substitutions
case "$DB_TYPE" in
sqlite)
    SED_SCHEMA='s/%TSTYPE%/DATETIME/g'
    CLIENT_CMD="sqlite3 '$DB_FILE'"
    ;;
postgres)
    SED_SCHEMA='s/%TSTYPE%/TIMESTAMPTZ/g'
    CLIENT_CMD="psql -qAt -h '$PGHOST' -p '$PGPORT' -U '$PGUSER' -d '$PGDATABASE'"
    ;;
*)
    echo "[power-logger] ERROR: unsupported DB_TYPE='$DB_TYPE'" >&2
    exit 1
    ;;
esac

# Initialize schema
echo "$INIT_SCHEMA_SQL" | sed "$SED_SCHEMA" | eval "$CLIENT_CMD"

# Determine starting slot
last_slot=$(echo "$SELECT_LAST_SLOT" | eval "$CLIENT_CMD")
case "$last_slot" in
'' | *[!0-9]*) slot=0 ;;                           # invalid
*) slot=$(((last_slot + 1) % RING_BUFFER_SIZE)) ;; # wrap
esac

apcaccess_value() {
    eval "$APCACCESS_BIN $APCACCESS_ARGS -u -p $1"
}

# Extract numeric watts from IPMI SDR output.
ipmi_power_meter() {
    eval "$IPMI_CMD" 2>/dev/null | awk -F'|' -v name="$IPMI_SENSOR" '
        $1 ~ name { gsub(/[^0-9.]/, "", $2); if ($2 != "") { print $2; exit } }
    '
}

# Startup delay to ensure unique integer-second timestamps
sleep 1

case "$POWER_SOURCE" in
apc)
    # Fetch NOMPOWER once (constant for the UPS)
    while :; do
        NOMPOWER=$(apcaccess_value NOMPOWER 2>/dev/null || true)
        case "$NOMPOWER" in
        '' | *[!0-9.]*)
            echo "[power-logger] WARN: invalid NOMPOWER='$NOMPOWER'. Retrying..." >&2
            sleep 5
            ;;
        *)
            break
            ;;
        esac
    done
    ;;
ipmi) ;;
*)
    echo "[power-logger] ERROR: unsupported POWER_SOURCE='$POWER_SOURCE'" >&2
    exit 1
    ;;
esac

while :; do
    # Wait until the scheduled next whole second
    while :; do
        now=$(date -u +%s)
        [ "$now" -ge "${next_tick:-0}" ] && break
        sleep 0.1
    done
    next_tick=$((now + INTERVAL_SEC))

    case "$POWER_SOURCE" in
    apc)
        LOADPCT=$(apcaccess_value LOADPCT 2>/dev/null || true)
        case "$LOADPCT" in
        '' | *[!0-9.]*)
            echo "[power-logger] WARN: invalid LOADPCT='$LOADPCT'." >&2
            continue
            ;;
        esac
        WATTS=$(echo "$LOADPCT * $NOMPOWER / 100" | bc -l)
        ;;
    ipmi)
        LOADPCT="0"
        WATTS=$(ipmi_power_meter 2>/dev/null || true)
        ;;
    esac

    case "$WATTS" in
    '' | *[!0-9.]*)
        echo "[power-logger] WARN: invalid watts='$WATTS'." >&2
        continue
        ;;
    esac

    SQL=$(echo "$UPSERT_SQL" |
        sed "s/%SLOT%/$slot/; s/%WATTS%/$WATTS/; s/%LOADPCT%/$LOADPCT/")
    echo "$SQL" | eval "$CLIENT_CMD"
    slot=$(((slot + 1) % RING_BUFFER_SIZE))
done
