#!/bin/sh
# runit service "pinger": keepalives & latency logging
# Supports SQLite file or PostgreSQL via Unix socket
# -------------------------------------------------------------
# Location: /etc/sv/pinger/run
# Service account: pinger
#
# Prerequisites (run once as root):
#   pw groupadd -n pinger || true
#   pw useradd -n pinger -g pinger -c "pinger service" -s /usr/sbin/nologin -d /nonexistent -w no || true
#   install -d -o pinger -g pinger /var/db/pinger
#   install -d -o root -g pinger -m 755 /etc/sv/pinger/env
#   cat > /etc/sv/pinger/env/.env.pinger <<'EOF'
#   RING_BUFFER_DAYS=30
#   TARGET=2001:470:20::2
#   DB_TYPE=sqlite
#   EOF
#   chmod o= /etc/sv/pinger/env/.env.pinger
#   chown -R root:pinger /etc/sv/pinger
#
# If using PostgreSQL, also set PGHOST, PGPORT, PGDATABASE, PGUSER in the .env file.
# -------------------------------------------------------------
# Enable service: ln -s /etc/sv/pinger /var/service/

set -eu

# Drop privileges if needed
current_user=$(id -un)
if [ "$current_user" != "pinger" ]; then
    exec chpst -u pinger /bin/sh "$0" "$@"
fi

# Load environment
ENV_DIR="$(dirname "$0")/env"
[ -f "$ENV_DIR/.env.pinger" ] && . "$ENV_DIR/.env.pinger"

# Defaults
: "${RING_BUFFER_DAYS:=30}"
: "${TARGET:=2001:470:20::2}"
: "${DB_TYPE:=sqlite}"
: "${DB_FILE:=/var/db/pinger/pings.db}"
: "${PGHOST:=/tmp}"
: "${PGPORT:=5432}"
: "${PGDATABASE:=pinger_db}"
: "${PGUSER:=pinger}"
RING_BUFFER_SIZE=$((RING_BUFFER_DAYS * 86400))

# Common SQL templates
INIT_SCHEMA_SQL=$(
    cat <<'EOS'
-- SQLite or PostgreSQL schema initialization
CREATE TABLE IF NOT EXISTS pings (
    slot       INTEGER PRIMARY KEY,
    ts         %TSTYPE% NOT NULL DEFAULT CURRENT_TIMESTAMP UNIQUE,
    latency_ms REAL   NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_pings_ts ON pings(ts);
EOS
)

UPSERT_SQL=$(
    cat <<'EOS'
-- SQLite or PostgreSQL upsert
INSERT INTO pings(slot, latency_ms) VALUES(
    %SLOT%, %RTT%
) ON CONFLICT(slot) DO UPDATE SET
    ts         = CURRENT_TIMESTAMP,
    latency_ms = EXCLUDED.latency_ms;
EOS
)

# SQL to fetch last slot
SELECT_LAST_SLOT="SELECT slot FROM pings ORDER BY ts DESC LIMIT 1;"

# Determine client command and schema substitutions
case "$DB_TYPE" in
sqlite)
    SED_SCHEMA='s/%TSTYPE%/DATETIME/g'
    CLIENT_CMD="sqlite3 '$DB_FILE'"
    ;;
postgres)
    SED_SCHEMA='s/%TSTYPE%/TIMESTAMPTZ/g'
    CLIENT_CMD="psql -qAt -h '$PGHOST' -p '$PGPORT' -U '$PGUSER' -d '$PGDATABASE'"
    ;;
*)
    echo "[pinger] ERROR: unsupported DB_TYPE='$DB_TYPE'" >&2
    exit 1
    ;;
esac

# Initialize schema
echo "$INIT_SCHEMA_SQL" | sed "$SED_SCHEMA" | eval "$CLIENT_CMD"

# Determine starting slot
last_slot=$(echo "$SELECT_LAST_SLOT" | eval "$CLIENT_CMD")
case "$last_slot" in
'' | *[!0-9]*) slot=0 ;;                           # invalid
*) slot=$(((last_slot + 1) % RING_BUFFER_SIZE)) ;; # wrap
esac

# Startup delay to ensure unique integer-second timestamps
sleep 1

# Main loop: keep a strict 1 Hz cadence aligned to wall-clock seconds
while :; do
    # Wait until the scheduled next whole second
    while :; do
        now=$(date -u +%s)
        [ "$now" -ge "${next_tick:-0}" ] && break
        # Fractional sleep is supported on FreeBSD sleep(1); use short naps
        sleep 0.1
    done
    next_tick=$((now + 1))

    # One probe with a 1-second timeout (BSD ping6 uses seconds for -W)
    rtt=$(ping6 -c 1 -W 1 -q "$TARGET" 2>/dev/null | awk -F/ '/[Mm]in\/avg\/max/ {print $5; exit}')

    if [ -n "$rtt" ]; then
        # Render upsert SQL via sed
        SQL=$(echo "$UPSERT_SQL" |
            sed "s/%SLOT%/$slot/; s/%RTT%/$rtt/")
        echo "$SQL" | eval "$CLIENT_CMD"
        slot=$(((slot + 1) % RING_BUFFER_SIZE))
    fi
done
